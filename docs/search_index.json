[
["preface.html", "A Selection of R Programming Topics Preface", " A Selection of R Programming Topics Mark Banghart 2019-11-10 Preface The chapters of this book are materials from training seminars that I have given. "],
["1-data-objects.html", "1 Data objects", " 1 Data objects This chapter covers the commonly used data objects and their properties. This chapter is not complete. "],
["1-1-base-type-data-objects.html", "1.1 Base type data objects", " 1.1 Base type data objects 1.1.1 Integers, real numbers, character strings, and logical A datum is a single value. An integer, real number, character string, and logical value are examples of a datum. This type of data is called atomic. Atomic datum are stored in vectors, atomic vectors specifically. The positions within an atomic vector where an atomic datum is stored are called elements. The elements of a vector are organized serially, one after another. The elements have a position in this serial structure and the structure has a length. Since there is no branching in the serial structure, an atomic vector is a one dimensional structure. Atomic vectors contain data of a single type. The type of an atomic vectors is the type of the data it holds. The four most common types are integer, double, character, and logical. (Note, real numbers have a type of double.) There are two other types of atomic vectors, complex and raw. These two types will not be covered here. A few useful functions c() constructs an atomic vector. The type of the vector is determined by the data provided. If the data provided to c() are of different types, R will coerce, change the type for you, to the most flexible type in the data. The coercion order is logical to integer to double to character. There are constructors for vectors of each type, logical(), integer(), double(), numeric(), vector(). (Note, numeric() creates an atomic vector of type double.) These constructors create an atomic vector of a given length. The values for the elements will be FALSE for logical, 0 for integer and double, and \"\" for character types. typeof() returns the type of the data that is stored in an atomic vector. is.atomic() returns TRUE if the object is an atomic vector, otherwise FALSE. is.vector() returns TRUE if the data object is a vector. (This will be expanded on in the matrices section. This definition works for now.) 1.1.1.1 Examples Creating atomic vectors The following is an integer vector. The L after the integer indicates that the value is an integer. Without the L, the values are stored as double. vec1 &lt;- c(7L, 5L, 3L, 1L) vec1 [1] 7 5 3 1 The following is a vector of type double. vec2 &lt;- c(1, 2, 4, 8) vec2 [1] 1 2 4 8 The following is a character vector. vec3 &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;) vec3 [1] &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; The following is a logical vector. vec4 &lt;- c(TRUE, FALSE, FALSE, TRUE) vec4 [1] TRUE FALSE FALSE TRUE Coercion of type when creating atomic vectors The following includes logical, integer, and double values. The logical and integer values are coerced to double. vecA &lt;- c(TRUE, 1L, 2) vecA [1] 1 1 2 The following includes double and character values. The double value is coerced to character. vecB &lt;- c(3.5, &quot;4.6&quot;) vecB [1] &quot;3.5&quot; &quot;4.6&quot; typeof() atomic vectors The following displays the types of the vectors created in the prior examples. c(vec1 = typeof(vec1), vec2 = typeof(vec2), vec3 = typeof(vec3), vec4 = typeof(vec4), vecA = typeof(vecA), vecB = typeof(vecB) ) vec1 vec2 vec3 vec4 vecA vecB &quot;integer&quot; &quot;double&quot; &quot;character&quot; &quot;logical&quot; &quot;double&quot; &quot;character&quot; is.atomic() to test if a vector is atomic The following shows that all of the vectors created in the prior examples are atomic. c(vec1 = is.atomic(vec1), vec2 = is.atomic(vec2), vec3 = is.atomic(vec3), vec4 = is.atomic(vec4), vecA = is.atomic(vecA), vecB = is.atomic(vecB) ) vec1 vec2 vec3 vec4 vecA vecB TRUE TRUE TRUE TRUE TRUE TRUE A single datum is stored in vectors. All atomic datum are stored in a vector. Even one individual value, called a scalar, is stored in a vector. is.vector(9) [1] TRUE 1.1.2 Lists Lists store elements sequentially Thus, like atomic vectors are ordered single dimensional structures. They differ from atomic vectors in that the elements are other object, and not atomic data. The elements are typically atomic vectors or another list. Elements can also be any other R object, including non-data objects such as a function. List elements are not required to all be of the same object type. That is one element could be an atomic vector and another element could be another list. The type of a list is list. A list is a vector, just non-atomic. The constructor for a list is list(). 1.1.2.1 Examples Creating a list The following code creates a list with three elements. The first element is a character atomic vector of length one. The second element is vec1, an atomic vector from the prior examples, and the third vector is another list. The list in the third element contains two elements, each of which is an atomic vector. list1 &lt;- list(&quot;element_1&quot;, vec1, list(9, 0)) list1 [[1]] [1] &quot;element_1&quot; [[2]] [1] 7 5 3 1 [[3]] [[3]][[1]] [1] 9 [[3]][[2]] [1] 0 Note, the elements of a list are identifyed using two sets of square brackets, [[ ]]. typeof() list The following displays the type of list1 is list. typeof(list1) [1] &quot;list&quot; A list is still a vector is.vector(list1) [1] TRUE A list is not atomic Although the elements of a list may store atomic values. The list itself is not atomic. is.atomic(list1) [1] FALSE 1.1.3 Properties and attributes Properties are information about what is stored in a data object. They describe aspects of how the data is formatted and stored. Properties are metadata, data about the data. An example is, Type. A property that tells R how to interpret the data in the elements. Properties are set and controlled at a low level in R. A programmer does not directly set a property. Properties can be read using functions like typeof() and is.atomic(). An attribute is also data about the data. Attributes describe other meanings that the data may have. For example, A character vector may have an element that represents a person's name and another element that has their address. This information could be stored in an attribute. Users can define and change attributes. Base R defines some attributes for data objects, such as matrix and data.frame objects (which are covered in the next section.) A few useful functions length() returns the number of elements in an atomic vector or list. names() gets or sets the names of elements of an atomic vector or list. Names of elements are an attribute of the vector. attr() gets or sets a single attribute. attributes() gets all attributes of a data object. 1.1.3.1 Examples Naming elements We will use names() to give names to the four values stored in the elements of atomic vector vec1. names(vec1) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;) vec1 first second third fourth 7 5 3 1 names can also be given when the atomic vector or list is created. This is done by useing the name of an element as the parameter for the element rec_vec &lt;- c(name = &quot;Bucky&quot;, address = &quot;UW Madison&quot;, occupation = &quot;Mascot&quot;) rec_vec name address occupation &quot;Bucky&quot; &quot;UW Madison&quot; &quot;Mascot&quot; Similarly for lists. rec_list &lt;- list(name = &quot;Bucky&quot;, address = &quot;UW Madison&quot;, occupation = &quot;Mascot&quot;) rec_list $name [1] &quot;Bucky&quot; $address [1] &quot;UW Madison&quot; $occupation [1] &quot;Mascot&quot; length() of vectors The following displays the length of several of the vectors created in the prior examples. The lengths of the object are displayed using a named integer vector. c(vec1 = length(vec1), list1 = length(list1), rec_list = length(rec_list) ) vec1 list1 rec_list 4 3 3 The length of the rec_list is the count of it's elements. This does not include a count of any elements of objects stored in its elements. Getting attributes The following code displays the attributes of the rec_list list. attributes(rec_vec) $names [1] &quot;name&quot; &quot;address&quot; &quot;occupation&quot; The following code displays the names attributes of the rec_list list. attr(rec_vec, which = &quot;names&quot;) [1] &quot;name&quot; &quot;address&quot; &quot;occupation&quot; The following displays the attributes of vec3. Note, there are no attributes for this atomic vector. attributes(vec3) NULL 1.1.4 Summary (TL; DR) Vectors are data objects that store elements serially and are ordered one dimensionally structures. They have a type and length. Atomic indicates if data elements are integer, double, logical, or character. Lists are vectors where each element is an object. Elements of vectors can be given names. Properties of objects are controlled by R. There are functions that allow the properties to be viewed. Attributes are similar to properties. They can be set by the user. "],
["1-2-object-classes.html", "1.2 Object classes", " 1.2 Object classes There are three approaches to non base type data objects to R. All three of these approaches use a class to identify what data is stored in the object. The class of an object defines how the data is used as opposed to the type, which only identifies the format of what is stored in an element. For example, consider an object that is the result of some statistical test. The class of the object defines the meaning the data, some possible items might be, p-value, number of observations, etc. The type defines how it is stored, double, integer, etc. The S3 approach is the most common (as of the writing of this chapter) approach for adding classes. You have likely been using S3 objects without know it. Examples of S3 objects are, factor and data.frame. These classes are part of base R and are widely used. The details of the S3 approach are hidden from users of these data objects. The other two approaches for adding classed data objects are S4 and reference classes. S4 is the more common of the two and is used by packages such as lme4 and bioconductor. These will not be covered here. The rest of this section focuses on S3 classes. An S3 objects is a base type objects with a class attribute added. Depending on the class of the object, other attributes may be associated with the object. Base type objects have an implicit class. This class is not an attribute of the object. So, all object have a class. Not all objects use store the class as an attribute. A few useful functions class() returns the class of an object. The class may be a list of classes. factor() creates an object of class factor. data.frame() creates an object of class data.frame. matrix() creates an object of class matrix. is.vector() does not return TRUE if the object is one dimensional sequence of elements. It returns TRUE if the object type is one of the base types and it has no attribute other than names. This may seem like confusing behavior. You can understand it as determining if an object is a base type vector. 1.2.1 Factors Factors are used to represent categorical variables. Factors are integer atomic vectors. They have a levels attribute that stores the name of the level for each integer value of the factor. Depending where it is used, the factor may be used an integer, character, or a set of indicator variables. 1.2.1.1 Examples Creating a factor object The follow creates a factor object with two levels. vec5 &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;)) vec5 [1] A B A B Levels: A B The properties of a factor The type of a factor is integer. typeof(vec5) [1] &quot;integer&quot; The length of a factor is the number of elements. length(vec5) [1] 4 A factor is atomic, since elements are integer. is.atomic(vec5) [1] TRUE The is.vector() returns FALSE for a factor. is.vector(vec5) [1] FALSE The attributes of a factor. A factor object has class and levels attributes. attributes(vec5) $levels [1] &quot;A&quot; &quot;B&quot; $class [1] &quot;factor&quot; 1.2.2 data.frames The data.frame objects store table like data. They have rows and columns of data. There is a sequential order to both the rows and columns. A tibble is a tidyverse implementation of a data.frame. They are similar in many ways to a data.frame and will not be covered in this chapter. A data.frame is a list with elements with the following properties. The objects must be an atomic vector or a class object built on atomic vectors, such as factors. If the element is class object, it can not have a dim attribute. All elements must have the same length. The vectors can be of different types and class. A data.frame is a two dimensional structure, even if there is only a single column in the data frame. It is common for a data set to be organized such that the vectors are the variables and each row is an observation. 1.2.2.1 Examples Creating a data.frame Here a data frame is created using vec1, vec2, vec3, and vec4 as the columns of the data.frame. data_frame1 &lt;- data.frame(vec1, vec2, vec3, vec4) data_frame1 vec1 vec2 vec3 vec4 first 7 1 A TRUE second 5 2 B FALSE third 3 4 A FALSE fourth 1 8 B TRUE The properties of a data.frame. The type of a data.frame is list. typeof(data_frame1) [1] &quot;list&quot; The class of a data.frame is data.frame. class(data_frame1) [1] &quot;data.frame&quot; A data.frame is not atomic. is.atomic(data_frame1) [1] FALSE The length() of a data.frame is the number of columns in the data.frame. length(data_frame1) [1] 4 The attributes of a data.frame. attributes(data_frame1) $names [1] &quot;vec1&quot; &quot;vec2&quot; &quot;vec3&quot; &quot;vec4&quot; $class [1] &quot;data.frame&quot; $row.names [1] &quot;first&quot; &quot;second&quot; &quot;third&quot; &quot;fourth&quot; type is not used for dispatch. 1.2.3 Matrices There are two common packages that support matrix objects, base and matrix. The Matrix package supports a richer set of functions and accesses popular libraries for some calculations. Both of these matrix objects are virtual classes, a class that is not visible through the class attribute. They are not a base type and they also do not have an attribute of class. A matrix object is atomic with a dim, dimension, attribute. The length of the dim attribute must be two for matrices. 1.2.3.1 Examples Creating matrices The following creates a matrix defining the number of row. matrix1 &lt;- matrix(1:12, nrow = 3) matrix1 [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 The following creates a matrix defining the number of columns. matrix2 &lt;- matrix(1:12, ncol = 4) matrix2 [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 The following creates a matrix with the data given in row form. matrix3 &lt;- matrix( c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), ncol = 4, byrow = TRUE) matrix3 [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 rownames(matrix1) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) colnames(matrix1) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) matrix1 a b c d x 1 4 7 10 y 2 5 8 11 z 3 6 9 12 The properties of a matrix. typeof(matrix1) [1] &quot;integer&quot; is.atomic(matrix1) [1] TRUE length(matrix1) [1] 12 The attributes of a matrix. attributes(matrix1) $dim [1] 3 4 $dimnames $dimnames[[1]] [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; $dimnames[[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; 1.2.4 Summary (TL; DR) The following table displays the properties and class of common data objects. [1] &quot;vec1&quot; &quot;vec2&quot; &quot;vec3&quot; &quot;vec4&quot; &quot;vec5&quot; [6] &quot;list1&quot; &quot;matrix1&quot; &quot;data_frame1&quot; Warning: Setting row names on a tibble is deprecated. type class atomic is.numeric vector object vec1 integer integer TRUE TRUE TRUE FALSE vec2 double numeric TRUE TRUE TRUE FALSE vec3 character character TRUE FALSE TRUE FALSE vec4 logical logical TRUE FALSE TRUE FALSE vec5 integer factor TRUE FALSE FALSE TRUE list1 list list FALSE FALSE TRUE FALSE matrix1 integer matrix TRUE TRUE FALSE FALSE data_frame1 list data.frame FALSE FALSE FALSE TRUE "],
["2-functions.html", "2 Functions", " 2 Functions This chapter has not been added to the book. "],
["3-parallel-data-processing.html", "3 Parallel data processing", " 3 Parallel data processing This chapter has not been added to the book. "],
["4-matrices-1.html", "4 Matrices", " 4 Matrices This chapter covers some of the common math operations applied to matrices and vectors. This chapter assumes you already understand the object structure of vectors and matrices. If you need to review these concepts, see the chapter on data objects. The examples in this chapter will use the vectors and matrices created in the following code. x1 &lt;- -2:3 x2 &lt;- c(0, 1, 0, 1, 0, 1) (X &lt;- cbind(x1, x2)) x1 x2 [1,] -2 0 [2,] -1 1 [3,] 0 0 [4,] 1 1 [5,] 2 0 [6,] 3 1 w1 &lt;- c(2, -4, 1) w2 &lt;- c(-3, 1, 5) (W &lt;- cbind(w1, w2)) w1 w2 [1,] 2 -3 [2,] -4 1 [3,] 1 5 The dimensions of the X matrix are \\(6 \\times 2\\) and W are \\(3 \\times 2\\). "],
["4-1-scalar-operations.html", "4.1 Scalar operations", " 4.1 Scalar operations Scalar operations with vectors and matrices are done by applying the scalar operation to each element of the structure. A few examples Adding and subtracting a scalar Here the integer 3 is subtracted from the x1 vector. tibble(x1, `x1 - 3` = x1 - 3L) # A tibble: 6 x 2 x1 `x1 - 3` &lt;int&gt; &lt;int&gt; 1 -2 -5 2 -1 -4 3 0 -3 4 1 -2 5 2 -1 6 3 0 Here 2 is added to the matrix W. W + 2 w1 w2 [1,] 4 -1 [2,] -2 3 [3,] 3 7 Multiplication and division with a scalar Here x1 is multiplied by 5. tibble(x1, `x1 * 5` = x1 * 5) # A tibble: 6 x 2 x1 `x1 * 5` &lt;int&gt; &lt;dbl&gt; 1 -2 -10 2 -1 -5 3 0 0 4 1 5 5 2 10 6 3 15 Here W is divided by 2 W / 2 w1 w2 [1,] 1.0 -1.5 [2,] -2.0 0.5 [3,] 0.5 2.5 "],
["4-2-element-wise-operations.html", "4.2 Element-wise operations", " 4.2 Element-wise operations The +, *, -, and / operators are element-wise operators. These operators are applied to each paired element in two matrices or vectors. For example, element addition of two matrices is the element at row one column one of first matrix added with element at row one column one of the second matrix and similarly for all the other row and column elements. These paired element operations require both structure are the same shape, vectors of the same length and matrices with the same dimensions. Element-wise operations can also be done with a vector and matrix, if the length of the vector is the same as the number of rows of the matrix. The operation is done by applying the vector operation to each column of the matrix. A few examples Adding and subtracting element-wise Here x1 is added to x2. tibble(x1, x2, `x1 + x2` = x1 + x2) # A tibble: 6 x 3 x1 x2 `x1 + x2` &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 -2 0 -2 2 -1 1 0 3 0 0 0 4 1 1 2 5 2 0 2 6 3 1 4 Here a matrix W2 is created by replicating W and stacking the two W matrices. The W2 matrix has dimensions of \\(6 \\times 2\\). W2 is then subtracted from X. W2 &lt;- rbind(W, W) data.frame(X, W2, `X - W2` = X - W2) x1 x2 w1 w2 X...W2.x1 X...W2.x2 1 -2 0 2 -3 -4 3 2 -1 1 -4 1 3 0 3 0 0 1 5 -1 -5 4 1 1 2 -3 -1 4 5 2 0 -4 1 6 -1 6 3 1 1 5 2 -4 # data.frame is used here instead of tibble becase it # accepts matrices Multiplying and dividing element-wise Here X and W2 are multiplied. tibble(x1, x2, `x1 * x2` = x1 * x2) # A tibble: 6 x 3 x1 x2 `x1 * x2` &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 -2 0 0 2 -1 1 -1 3 0 0 0 4 1 1 1 5 2 0 0 6 3 1 3 Here w2 is divided by w1. data.frame(w2, w1, `w2 / w1` = w2 / w1) w2 w1 w2...w1 1 -3 2 -1.50 2 1 -4 -0.25 3 5 1 5.00 Element-wise operations with a vector and a matrix The addition of x1 to the W2 matrix is the application of add x1 to each column of W2. data.frame(x1, W, `x1 + W2` = x1 + W2) x1 w1 w2 x1...W2.w1 x1...W2.w2 1 -2 2 -3 0 -5 2 -1 -4 1 -5 0 3 0 1 5 1 5 4 1 2 -3 3 -2 5 2 -4 1 -2 3 6 3 1 5 4 8 "],
["4-3-matrix-multiplication-operator.html", "4.3 Matrix multiplication operator", " 4.3 Matrix multiplication operator The matrix multiplication operator is %*%. The left operand, say A is said to be left multiplied to the right operand B. Similarly, the right operand is right multiplied to the left operand. The code for this can be written by, A %*% B. The %*% can operate on (atomic) vectors by promoting them to matrix with either one row or one column. These will be referred to as row vectors or column vectors. When left operand is a row vector and right operand is a column vectors, the operation is called the dot product. 4.3.1 dot product The dot product of two vectors is the sum of the element-wise products. For example, the dot product of vector c and d is calculated as, \\[\\sum_{i=1}^n c_i \\cdot d_i.\\] The mathematical notation for the dot product is \\(c \\cdot d\\). When a (atomic) vector is used as one of the operands of %*%, R promotes it to a row or column matrix as needed for the operation. Dot product using matrix multiplication Here the dot product of vectors x1 and x2 is calculated using the matrix multication. The %*% operater will promote x1 to a row vector and x2 to a column vector. x1 %*% x2 [,1] [1,] 3 The promotion to a row or column vector can be done manually as is demonstated in the following code. matrix(x1, nrow = 1) %*% matrix(x2, ncol = 1) [,1] [1,] 3 The left multiplication of a column vector with a row vector does not result in a dot product as is demonstrated in the following code. matrix(x1, ncol = 1) %*% matrix(x2, nrow = 1) [,1] [,2] [,3] [,4] [,5] [,6] [1,] 0 -2 0 -2 0 -2 [2,] 0 -1 0 -1 0 -1 [3,] 0 0 0 0 0 0 [4,] 0 1 0 1 0 1 [5,] 0 2 0 2 0 2 [6,] 0 3 0 3 0 3 Calculate the dot product using the definition The following calculates the same dot product as in example 1, using the sum of the products of the elements. The results are the same as in example 1. sum(x1 * x2) [1] 3 Calculate the dot product using crossprod() The following calculates the same dot product as in example 1, using the crossprod() function. The results are the same as in example 1. crossprod(x1, x2) [,1] [1,] 3 4.3.2 Matrix multiplication A matrix A\\(_{[i, \\,j]}\\) can be multiplied with a matrix B\\(_{[j, \\,k]}\\), if the number of columns in A is the same as the number of rows in B. The result of this multiplication is a matrix with dimensions of \\(i \\times k\\). This is, \\[A_{[i, \\,j]} \\cdot B_{[j,\\, k]} \\ = \\ (AB)_{[i, \\,k]}.\\] Each element of \\((AB)\\) is the dot product of a row from A with a column from B. Matrix multiplication is commutative. Multiply W with X transpose. The transpose function, t(), can be used to switch the columns of a matrix with its rows. Note, this switches the dimension of the matrix as well. The transpose of a matrix, say A, is writen as A'. The transpose of X results in a matrix with two rows. One with x1 and the other with x2. t(X) [,1] [,2] [,3] [,4] [,5] [,6] x1 -2 -1 0 1 2 3 x2 0 1 0 1 0 1 The following code left multiplies matrix W with the transpose of X. W %*% t(X) [,1] [,2] [,3] [,4] [,5] [,6] [1,] -4 -5 0 -1 4 3 [2,] 8 5 0 -3 -8 -11 [3,] -2 4 0 6 2 8 The following is the dot product of row two of W with column four of X transpose. Try other row and column values to confirm that each element of WX' is the dot product of the row of W and column of X transpose. W[2,] %*% t(X)[, 4] [,1] [1,] -3 X' multiplied by W2 In this example the order of the matrices is switched from the prior example. This results is a different matrix. This shows that matrix multiplication is not commutative. t(X) %*% W2 w1 w2 x1 -3 19 x2 -1 3 4.3.3 Outer product When the left operand is a column vector and the right operand is a row vector, matrix multiplication is the outer product. The outer product of x2 and x1. This example reverses the order of the matrices from example 1 of the dot product section. This is another example of matrix multiplication not being commutative. matrix(x2, ncol = 1) %*% matrix(x1, nrow = 1) [,1] [,2] [,3] [,4] [,5] [,6] [1,] 0 0 0 0 0 0 [2,] -2 -1 0 1 2 3 [3,] 0 0 0 0 0 0 [4,] -2 -1 0 1 2 3 [5,] 0 0 0 0 0 0 [6,] -2 -1 0 1 2 3 Calculate the prior example using outer(). outer(x2, x1) [,1] [,2] [,3] [,4] [,5] [,6] [1,] 0 0 0 0 0 0 [2,] -2 -1 0 1 2 3 [3,] 0 0 0 0 0 0 [4,] -2 -1 0 1 2 3 [5,] 0 0 0 0 0 0 [6,] -2 -1 0 1 2 3 "],
["4-4-matrix-inversion.html", "4.4 Matrix inversion", " 4.4 Matrix inversion A square matrix A\\(_{[n, \\,n]}\\) is invertable if it is full rank. B is the inverse of A if A %*% B = I\\(_{[n, \\,n]}\\). The inverse of a matrix, say A, is written as, A\\(^{-1}\\). How to calculate an inverse is beyond the scope of this chapter. Please see a linear algebra text book for this information. Create a square matrix. Here a square matrix is made by mutliplying a matrix by its transpose. This always results in a square matrix. The square matrix will be full rank, if none of the columns of the origin matrix is a linear combination of the other columns. The columns of XI are linearly independent of each other, therefore, we are sure that XtX is full rank. XI &lt;- cbind(1, X) (XtX &lt;- t(XI) %*% XI) x1 x2 6 3 3 x1 3 19 3 x2 3 3 3 Inverting a matrix using solve(). The solve() function will invert a matrix. This method of inverting a matrix can be numerically unstable if the matrix has a column that is close to linearly dependent. (XtXi &lt;- solve(XtX)) x1 x2 0.3333333 0.0000 -0.3333333 x1 0.0000000 0.0625 -0.0625000 x2 -0.3333333 -0.0625 0.7291667 Invert using qr() and chol2inv(). This example uses qr() to decompose the matrix. QR &lt;- qr(XI) The QR decomposition can be used in chol2inv() to invert the matrix. (XtXi2 &lt;- chol2inv(qr.R(QR))) [,1] [,2] [,3] [1,] 3.333333e-01 -1.040834e-17 -0.3333333 [2,] -1.040834e-17 6.250000e-02 -0.0625000 [3,] -3.333333e-01 -6.250000e-02 0.7291667 This results in the same inverse matrix. The use of qr() and chol2inv() is more numerically stable. all.equal(XtXi2, XtXi, check.attributes = FALSE) [1] TRUE "],
["4-5-other-matrix-operations.html", "4.5 Other Matrix operations", " 4.5 Other Matrix operations This section covers a few additional functions useful with matrices. 4.5.1 The diag() function The diag() function can be used to return the diagonal values of a matrix or to generate a diagonal matrix. Get the diagonal values of a matrix. diag() will return the diagonals as an atomic vector. diag(XtXi) x1 x2 0.3333333 0.0625000 0.7291667 Creating a diagonal matrix from a scalar value. Here a three by three identity matrix is created. An identy matrix is a matrix 1 on the diagonal and 0 everywhere else. diag(1,nrow = 3) [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 1 0 [3,] 0 0 1 Create a diagonal matrix from a vector. Here a four by four matrix is created with 1, 2, 3, and 4 on the diagonal. diag(1:4) [,1] [,2] [,3] [,4] [1,] 1 0 0 0 [2,] 0 2 0 0 [3,] 0 0 3 0 [4,] 0 0 0 4 4.5.2 The eigen() function The eigen() function returns the eigen values and eigen vectors of a matrix. The eigen decomposition of XtXi eigen(XtXi) eigen() decomposition $values [1] 0.92234843 0.15365000 0.04900156 $vectors [,1] [,2] [,3] [1,] -0.49153574 0.8370643 0.2402415 [2,] -0.06313365 -0.3093935 0.9488360 [3,] 0.86856592 0.4512195 0.2049249 4.5.3 The model.matrix() function Create a data frame with a factor variable Here a three level factor variable is included with x1 and x2 in a data frame. (XE &lt;- data.frame(X, c1 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;))) x1 x2 c1 1 -2 0 A 2 -1 1 B 3 0 0 C 4 1 1 A 5 2 0 B 6 3 1 C Using model.matrix() to create a matrix from a formula. Calling model.frame can be helpful to prepare the data. (dm &lt;- model.matrix(~ x1*x2 + c1, XE)) (Intercept) x1 x2 c1B c1C x1:x2 1 1 -2 0 0 0 0 2 1 -1 1 1 0 -1 3 1 0 0 0 1 0 4 1 1 1 0 0 1 5 1 2 0 1 0 0 6 1 3 1 0 1 3 attr(,&quot;assign&quot;) [1] 0 1 2 3 3 4 attr(,&quot;contrasts&quot;) attr(,&quot;contrasts&quot;)$c1 [1] &quot;contr.treatment&quot; "],
["4-6-solving-ordinary-least-squares-ols.html", "4.6 Solving Ordinary Least Squares (OLS)", " 4.6 Solving Ordinary Least Squares (OLS) This section is a set of examples that calculate the coefficients and standard errors for an OLS model. The XI matrix will be used as the design matrix for the model. It contains a column of 1 for the intercept, x1, and x2. Create a response variable set.seed(8474352) (y &lt;- 2 * x1 + x2 - 3 + rnorm(length(x1), sd = .05)) [1] -7.07970311 -4.06525197 -3.02161199 0.06841643 0.94076842 3.99357054 Calculate the coefficients for the model The solve.qr() function provides a numerically stable solution for the coefficients of an OLS model. (betahat &lt;- solve.qr(QR, y)) x1 x2 -3.053516 2.009912 1.042515 This could also be solved using matrix multiplication. (beta &lt;- XtXi %*% t(XI) %*% y) [,1] -3.053516 x1 2.009912 x2 1.042515 Calculating the predicted responses. (y_hat &lt;- XI %*% beta) [,1] [1,] -7.073339071 [2,] -4.020911843 [3,] -3.053515560 [4,] -0.001088332 [5,] 0.966307951 [6,] 4.018735179 Calculate \\(\\sigma\\) The standard error the error terms is calculated by dividing the residual sum of squares by the degrees of freedom of the model. (sigma_sq &lt;- sum((y_hat - y)^2) / (length(y) - ncol(X))) [1] 0.002285206 (sigma &lt;- sqrt(sigma_sq)) [1] 0.04780383 Calculate the standard errors of the coefficients. The standard errors of the coefficients are \\(\\sigma\\) times the diaganol of \\(X&#39;X\\). (se_beta &lt;- sigma * diag(XtXi)) x1 x2 0.015934610 0.002987739 0.034856960 Results from lm(). The values of \\(\\sigma\\), the coefficients, and their standard error can be checked against those of lm() below. summary(lm(y ~ x1 + x2)) Call: lm(formula = y ~ x1 + x2) Residuals: 1 2 3 4 5 6 -0.006364 -0.044340 0.031904 0.069505 -0.025540 -0.025165 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -3.05352 0.03187 -95.81 2.51e-06 *** x1 2.00991 0.01380 145.65 7.14e-07 *** x2 1.04252 0.04714 22.12 0.000202 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.0552 on 3 degrees of freedom Multiple R-squared: 0.9999, Adjusted R-squared: 0.9998 F-statistic: 1.29e+04 on 2 and 3 DF, p-value: 1.254e-06 "]
]
